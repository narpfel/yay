TODO
====


Target handling in mnemonics
----------------------------

Calling a mnemonic should let the mnemonic append it`self` to its `target`.
This way, the `Program` has kind of a syntax tree that it can (post-)process
later. It should be possible for `with`-blocks to alter the mnemonicsâ€™ targets
in order to capture the mnemonics in their blocks to customize program
behaviour. For that, the mnemonics should receive a callable (e. g. a method
of `Program`) that returns the actual `target` so that the target itself can
be easily replaced for all mnemonics.

To assist [TODO: ???]


`LD` mnemonic
-------------

When writing a macro, it is useful to accept direct as well as register and
indirect addresses as arguments. If this is the case, `LDA`, `LDD` and `LDI`
cannot be used anymore because they encode their argument type in their names.
Introducing a polymorphic mnmonic `LD` will solve this problem. It should
be made clear that in situations when the argument type is known at write
time, for clarity reasons the specialized `LDA`, `LDD` and `LDI` are preferred.


Clean macros
------------

Macros should not pollute the global `Label` namespace with their labels.
An easy solution would be to introduce a method `new_label(self, prefix: str)`
on `Program` that returns a new label with given prefix (for readability) that
is not yet present in the `Program` instance. The generated label could
consist of the prefix and either a deterministic or a random suffix.

A cleaner solution would be to capture labels generated by macros and remove
them from the `Program.labels` dict after the macro has finished executing.


`infinitely` macro
------------------

```py
with infinitely():
    ...
```

should be equivalent to
```py
Label("loop")
...
SJMP("loop")
```

Possible implementation:
```py
@block_macro
def infinitely(self, jmp=None):
    if jmp is None:
        jmp = SJMP
    loop = self.new_label("loop")
    yield
    jmp(loop)
```

